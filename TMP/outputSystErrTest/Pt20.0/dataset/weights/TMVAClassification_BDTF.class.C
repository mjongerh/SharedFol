// Class: ReadBDTF
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTF
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.24/06       [399366]
Creator        : mjongerh
Date           : Wed Feb 23 15:19:37 2022
Host           : Linux alicecerno2 5.4.0-90-generic #101-Ubuntu SMP Fri Oct 15 20:00:55 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/mjongerh/alice/SharedFol/CERN/Lb
Training events: 3408
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
UseFisherCuts: "True" [Use multivariate splits using the Fisher criterion]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 7
fCPA                          fCPA                          fCPA                          fCPA                          units                             'F'    [0.950171411037,1]
fCPAXY                        fCPAXY                        fCPAXY                        fCPAXY                        units                             'F'    [0.822591364384,1]
fChi2PCA                      fChi2PCA                      fChi2PCA                      fChi2PCA                      units                             'F'    [1.93354407861e-16,9.79380638455e-05]
fDecayLength                  fDecayLength                  fDecayLength                  fDecayLength                  units                             'F'    [0.00542215676978,2.50995516777]
fDecayLengthXY                fDecayLengthXY                fDecayLengthXY                fDecayLengthXY                units                             'F'    [0.00500299409032,1.39769160748]
fImpactParameter0             fImpactParameter0             fImpactParameter0             fImpactParameter0             units                             'F'    [-0.186275333166,0.305018126965]
fImpactParameter1             fImpactParameter1             fImpactParameter1             fImpactParameter1             units                             'F'    [-0.665639877319,0.7682929039]
NSpec 4
fPtProng0                     fPtProng0                     fPtProng0                     fPtProng0                     units                             'F'    [2.34326553345,23.5457839966]
fPtProng1                     fPtProng1                     fPtProng1                     fPtProng1                     units                             'F'    [0.505312681198,20.8800621033]
fM                            fM                            fM                            fM                            units                             'F'    [4.62602806091,6.53072166443]
fPt                           fPt                           fPt                           fPt                           Gev                               'F'    [20.001335144,23.9997196198]


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTFNode

#ifndef BDTFNode__def
#define BDTFNode__def

class BDTFNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDTFNode ( BDTFNode* left,BDTFNode* right,
                          int nFisherCoeff,
                          double fisherCoeff0,
                          double fisherCoeff1,
                          double fisherCoeff2,
                          double fisherCoeff3,
                          double fisherCoeff4,
                          double fisherCoeff5,
                          double fisherCoeff6,
                          double fisherCoeff7,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fNFisherCoeff ( nFisherCoeff ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
     fFisherCoeff.push_back(fisherCoeff0);
     fFisherCoeff.push_back(fisherCoeff1);
     fFisherCoeff.push_back(fisherCoeff2);
     fFisherCoeff.push_back(fisherCoeff3);
     fFisherCoeff.push_back(fisherCoeff4);
     fFisherCoeff.push_back(fisherCoeff5);
     fFisherCoeff.push_back(fisherCoeff6);
     fFisherCoeff.push_back(fisherCoeff7);
   }

   virtual ~BDTFNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTFNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTFNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTFNode*   fLeft;     // pointer to the left daughter node
   BDTFNode*   fRight;    // pointer to the right daughter node
   int                     fNFisherCoeff; // =0 if this node doesn't use fisher, else =nvar+1 
   std::vector<double>     fFisherCoeff;  // the fisher coeff (offset at the last element)
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTFNode::~BDTFNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTFNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
   if (fNFisherCoeff == 0){
     result = (inputValues[fSelector] >= fCutValue );
   }else{
     double fisher = fFisherCoeff.at(fFisherCoeff.size()-1);
     for (unsigned int ivar=0; ivar<fFisherCoeff.size()-1; ivar++)
       fisher += fFisherCoeff.at(ivar)*inputValues.at(ivar);
     result = fisher > fCutValue;
   }
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTFNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTF : public IClassifierReader {

 public:

   // constructor
   ReadBDTF( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDTF" ),
        fNvars( 7 )
   {
      // the training input variables
      const char* inputVars[] = { "fCPA", "fCPAXY", "fChi2PCA", "fDecayLength", "fDecayLengthXY", "fImpactParameter0", "fImpactParameter1" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTF() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[7];
   double fVmax[7];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[7];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTFNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTF::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTFNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTFNode*)current->GetRight();
         else current=(BDTFNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDTF::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(0.355218401622124);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.624553,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.278193,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999989, 0, 0, 0.551464,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999775, 0, 0, 0.52154,-99) , 
NN(
0, 
0, 
8, 0, 0, 0, 0.249725, 0.258654, 1.89511, 0.638388, -0.354154, -1, -0.0151101, 0, -1, 0.26116,-99) , 
8, 25.7573, -2.81109, 0, -0.168443, -0.0280442, 0, 0, -22.8949, 7, -0.0612312, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.235014);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.577147,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.383665,-99) , 
8, 2529.37, 118.915, 0, 0.0402083, -1.06398, 0, 0, -2648.14, 7, -0.0249276, 0, 0, 0.518663,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999731, 0, 0, 0.497761,-99) , 
NN(
0, 
0, 
8, 0, 0, 0, 0.00748416, 0.462723, 0, 0, -0.192775, -1, -0.0640303, 0, -1, 0.349111,-99) , 
8, 25.1534, -2.71803, 0, -0.0909333, -0.0882048, 0, 0, -22.3926, 7, -0.0129086, 0, 0, 0.465515,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.239756);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.565157,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.347868,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999995, 0, 0, 0.498564,-99) , 
NN(
0, 
0, 
8, 1379.12, -122.651, 0, -1.4314, 1.47553, 0.355559, 0.118076, -1256.17, -1, -0.0327898, 0, -1, 0.204042,-99) , 
8, 1221.9, -80.2095, 0, -0.248597, 0.145838, 0, 0, -1141.64, 7, -0.0545816, 0, 0, 0.478197,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.270277, 0, -1, 0.191634,-99) , 
8, 23.6882, -2.5779, 0, -0.0919954, 0.118259, 0, 0, -21.1036, 7, -0.0108972, 0, 0, 0.461631,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.203591);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.634348,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.382629,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.00241013, 0, 0, 0.586006,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.536474,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.359437,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00565583, 0, 0, 0.408334,-99) , 
8, 24.6082, -2.19126, 0, -0.206516, -3.21768, 0, 0, -22.2662, 7, 0.0037438, 0, 0, 0.504225,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.626411,-99) , 
NN(
0, 
0, 
8, 104.489, -65.8496, 0, -0.138312, 0.166185, 0, 0, -38.6351, -1, -0.0225827, 0, -1, 0.411465,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.884358, 0, 0, 0.420224,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.0713215, 1, 0, 0.447235,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.167911);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.633774,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.606372,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.358912,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.286696, 1, 0, 0.482379,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0643917, 0, 0, 0.52449,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.640533,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.4409,-99) , 
8, 451.74, 495.329, 0, -0.0196848, -1.66346, 0, 0, -946.94, 7, 0.0430446, 0, 0, 0.530769,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0689477, 0, -1, 0.434108,-99) , 
8, 24.5046, -2.6099, 0, 0.209995, -0.429698, 0, 0, -21.8663, 7, 0.0179114, 0, 0, 0.469114,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.024279, 0, 0, 0.476299,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.152318);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.579818,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.387397,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0572129, 0, 0, 0.558135,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.546469,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.313262,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.454136, 0, 0, 0.457038,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.354213, 1, 0, 0.525882,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.538313,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.199886,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999893, 0, 0, 0.510613,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.175705, 0, -1, 0.401285,-99) , 
8, 24.5803, -2.84298, 0, -0.793244, 0.555994, 0, 0, -21.6926, 7, -0.0126038, 0, 0, 0.485558,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.243949, 0, 0, 0.499349,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.0969222);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.552522,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.369759,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0600095, 1, 0, 0.529063,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.508523,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.346923,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.454136, 0, 0, 0.44738,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.354213, 1, 0, 0.503049,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.602278,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0193357, 0, -1, 0.462414,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.0167743, 1, 0, 0.469449,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.243949, 0, 0, 0.480917,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.140533);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.57702,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.464106,-99) , 
8, 1288.85, 108.979, 0, -0.147408, -0.101211, 0, 0, -1397.77, 7, 0.0222664, 0, 0, 0.51151,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
8, 582.838, -75.1288, 0, -0.22973, 0.0322631, 0, 0, -507.651, 7, -0.11189, 0, 0, 0.496564,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.346496,-99) , 
8, 24.2436, -2.67964, 0, -0.0564055, -0.00400035, 0, 0, -21.5456, 7, -0.0339022, 0, 0, 0.490389,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.229131);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.616773,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.418192,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999998, 0, 0, 0.534711,-99) , 
NN(
0, 
0, 
8, 929.705, -53.1261, 0, 0.168211, -0.365714, 1.92537, 0.55347, -876.493, -1, 0.00278382, 0, -1, 0.398468,-99) , 
8, 1151.06, 36.7781, 0, -0.0623209, -0.00208779, 0, 0, -1187.81, 7, -0.00680578, 0, 0, 0.511418,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
8, 23.5343, -2.59772, 0, -0.0251325, 0.0559213, 0, 0, -20.936, 7, -0.00994381, 0, 0, 0.498031,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.111881);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, 625.479, -68.3682, 0, -3.9216, -5.90008, 0, 0, -556.836, -1, 0.00498289, 0, 1, 0.597866,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.566252,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.439907,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.00549055, 1, 0, 0.484629,-99) , 
8, 23.5975, -2.34399, 0, -0.719403, -1.37929, 0, 0, -21.1514, 7, 0.0286437, 0, 0, 0.529302,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.534325,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.471383,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.361411, 1, 0, 0.510116,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.540268,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.415393,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.122424, 0, 0, 0.439143,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.134533, 0, 0, 0.487757,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.0713215, 1, 0, 0.501057,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0818059);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.536876, 1, 1, 0.584055,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.518886,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.275001,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999865, 0, 0, 0.507019,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.50595,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.34836,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.338306, 0, 0, 0.420352,-99) , 
8, 24.7263, -2.70984, 0, -0.0911116, -0.0871567, 0, 0, -21.9831, 7, -0.0213629, 0, 0, 0.493592,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.60174, 0, 0, 0.499815,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0494218);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.536876, 1, 1, 0.564055,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.366021, 1, -1, 0.478206,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.60174, 0, 0, 0.48409,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0834453);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.624281,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.492757,-99) , 
8, 341.243, -22.0482, 0, -2.43754, 0.116876, 0, 0, -319.059, 7, 0.0366871, 0, 0, 0.541345,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.319315,-99) , 
8, 23.4125, -2.36676, 0, -0.831398, -0.747177, 0, 0, -20.9633, 7, -0.0428916, 0, 0, 0.52068,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.675789,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.496794,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.562587, 1, 0, 0.582832,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.36779, 1, -1, 0.473257,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.652129, 0, 0, 0.482611,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.0713215, 1, 0, 0.494743,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0937718);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.64303,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.481629,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.558089, 1, 0, 0.563042,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.527558,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.126958,-99) , 
8, 545.52, -64.3262, 0, 0.00712719, -0.203773, 0, 0, -481.154, 7, -0.0662578, 0, 0, 0.515989,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.000289382, 1, -1, 0.338207,-99) , 
8, 24.3861, -2.67595, 0, -0.0870317, -0.0297744, 0, 0, -21.6857, 7, -0.0289525, 0, 0, 0.506279,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.469233, 0, 0, 0.510009,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0491374);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.024279, 0, 1, 0.566551,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.504133,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.161152,-99) , 
8, 545.873, -68.9728, 0, 0.0578874, -0.326085, 0, 0, -476.853, 7, -0.0591033, 0, 0, 0.491973,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.323103,-99) , 
8, 24.182, -2.61709, 0, 0.0513895, -0.17667, 0, 0, -21.5454, 7, -0.0324131, 0, 0, 0.486208,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.60174, 0, 0, 0.491659,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0743493);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.619997,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.49316,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.558089, 1, 0, 0.556551,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.608393,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.474036,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.444363, 0, 0, 0.481002,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.299677,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.379747, 1, 0, 0.475636,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.469233, 0, 0, 0.48092,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0497543);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.627747,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.49985,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.024279, 0, 0, 0.558319,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.507967,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.315503,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999865, 0, 0, 0.500102,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.344633,-99) , 
8, 24.3292, -2.65154, 0, -0.0337749, -0.100809, 0, 0, -21.6536, 7, -0.0290466, 0, 0, 0.492066,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.60174, 0, 0, 0.496529,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0486786);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.649885,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.4419,-99) , 
8, -251.364, -2565.02, -656665, 0, 0, 1.50148, 0.72215, 2816.39, 7, -0.00545826, 0, 0, 0.559558,-99) , 
NN(
0, 
0, 
8, 24.197, -2.64146, 0, -0.0552686, -0.0587408, 0, 0, -21.5337, -1, -0.0309203, 0, -1, 0.481859,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.60174, 0, 0, 0.487084,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.071702);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.558089, 1, 1, 0.560133,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.516757,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.409343,-99) , 
8, 521.797, -58.9187, 0, 0.0917892, -0.274607, 0, 0, -462.845, 7, -0.0179222, 0, 0, 0.503154,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.263874,-99) , 
8, 24.2225, -2.65453, 0, -0.0986308, -0.00354468, 0, 0, -21.5457, 7, -0.0306999, 0, 0, 0.49405,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.469233, 0, 0, 0.498324,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0702471);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.638981,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.486125,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1.45723e-08, 1, 0, 0.599624,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.318799,-99) , 
8, 7464.14, -7671.12, -218395, -0.0833679, 0.102022, 0, 0, 206.997, 7, -0.00303104, 0, 0, 0.536111,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.0572129, 0, -1, 0.478187,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.336596, 0, 0, 0.485728,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0768071);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0176933, 1, 1, 0.577654,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.520493,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.328713,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.0492201, 0, 0, 0.466267,-99) , 
8, 23.0148, -2.30636, 0, -0.780605, -0.631657, 0, 0, -20.6351, 7, 0.0070404, 0, 0, 0.523973,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.508862,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.44131,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0854678, 1, 0, 0.503124,-99) , 
NN(
0, 
0, 
8, 127.376, -102.402, 0, -1.02595, -1.06883, 0, 0, -24.754, -1, -0.00140676, 0, -1, 0.432543,-99) , 
8, 106.671, -65.2709, 0, 0.0229472, 0.0795415, 0, 0, -41.4242, 7, -0.0131395, 0, 0, 0.489838,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.0713215, 1, 0, 0.500658,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0674766);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.666839,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.510093,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.391982,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.02223, 0, 0, 0.492682,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.0158461, 1, 0, 0.510066,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.648269,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.491043,-99) , 
8, -733.157, -2075.96, -646337, 0, 0, 1.21638, 0.473009, 2809.12, 7, 0.0029374, 0, 0, 0.567529,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.513733, 1, -1, 0.472702,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.652129, 0, 0, 0.480483,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.0713215, 1, 0, 0.489836,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.171809);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.579696,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.439335,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999999, 0, 0, 0.518023,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.526311,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0800792,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.0615035, 1, 0, 0.382928,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999975, 0, 0, 0.505073,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.230588,-99) , 
8, 23.4194, -2.5294, 0, 0.00941742, 0.0172782, 0, 0, -20.8921, 7, -0.00619298, 0, 0, 0.496523,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0890137);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.556093,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.411646,-99) , 
8, 561.224, -86.7255, 0, -2.3318, 1.30647, 0, 0, -474.413, 7, -0.033948, 0, 0, 0.540764,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0078439, 1, -1, 0.442244,-99) , 
8, 24.1423, -2.5982, 0, -0.857109, 0.267582, 0, 0, -21.4973, 7, -0.0125867, 0, 0, 0.516646,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.58015,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.481723,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.88755, 0, 0, 0.489364,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.183946, 1, -1, 0.450039,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.238414, 0, 0, 0.473753,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.124686, 1, 0, 0.491765,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0378102);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.626468,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.50279,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.322505,-99) , 
8, 24.0556, -2.67491, 0, -0.264248, 0.261321, 0, 0, -21.3651, 7, -0.0361166, 0, 0, 0.494191,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0291009, 1, 0, 0.502053,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.462615,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0459058, 0, 0, 0.500189,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0441165);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.61725,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.567299,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.390229,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0510973, 1, 0, 0.465769,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.387269, 1, 0, 0.513507,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.0572129, 0, -1, 0.489344,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.336596, 0, 0, 0.492433,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0376021);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.687185,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.440681,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0403317, 0, 0, 0.586908,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.50363,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.290677,-99) , 
8, 24.1681, -2.6415, 0, -0.0972283, 0.0123546, 0, 0, -21.5078, 7, -0.0337998, 0, 0, 0.497434,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0363959, 1, 0, 0.50338,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.459781,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.535551, 1, 0, 0.50175,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.031984);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.598669,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.455569,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0171853, 0, 0, 0.522971,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.502359,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.390598,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0600095, 1, 0, 0.497008,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.375098,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.366021, 1, 0, 0.492038,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.60174, 0, 0, 0.49403,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0352797);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.59096,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.463512,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0171853, 0, 0, 0.523487,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.366021, 1, -1, 0.485423,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.60174, 0, 0, 0.48787,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.042657);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.604193,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.577134,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.401438,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0510973, 1, 0, 0.477085,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.387269, 1, 0, 0.516822,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.502119,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.396197,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0698434, 1, 0, 0.498133,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.383201,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0572129, 0, 0, 0.493149,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.336596, 0, 0, 0.496153,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.060506);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.593948,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.566691,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.41173,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0510973, 1, 0, 0.478484,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.387269, 1, 0, 0.514565,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.567328,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.48376,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0337045, 1, 0, 0.488032,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.375371,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0374858, 1, 0, 0.484171,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.336596, 0, 0, 0.488017,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0352193);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.601163,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.453087,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.558089, 1, 0, 0.527444,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.506131,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.396673,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0394458, 1, 0, 0.502282,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.336898,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.379747, 1, 0, 0.497651,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.469233, 0, 0, 0.499505,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0418064);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.592689,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.461828,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.558089, 1, 0, 0.527478,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.581347,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.489525,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.444363, 0, 0, 0.494095,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.34481,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.379747, 1, 0, 0.489937,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.469233, 0, 0, 0.492268,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0387712);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.621439,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.503871,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.290545,-99) , 
8, 24.2026, -2.70047, 0, -0.246524, 0.241787, 0, 0, -21.4873, 7, -0.0371959, 0, 0, 0.495128,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0291009, 1, 0, 0.502669,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.468907,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0459058, 0, 0, 0.50112,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0264872);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.605565,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.460226,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0171853, 0, 0, 0.528504,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.366021, 1, -1, 0.490633,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.60174, 0, 0, 0.493025,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0320983);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.599221,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.466812,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0171853, 0, 0, 0.528958,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.5055,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.419355,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0600095, 1, 0, 0.501416,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.398079,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.366021, 1, 0, 0.497253,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.60174, 0, 0, 0.499253,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0471643);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.643534,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.414924,-99) , 
8, 5630.19, -5820.98, -176413, 0, 0, 0.152263, 0.163889, 190.794, 7, 0.00685473, 0, 0, 0.530912,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.581911,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.489479,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0365599, 1, 0, 0.494192,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.362642,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.379747, 1, 0, 0.49056,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.469233, 0, 0, 0.493052,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0355157);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.612593,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.504634,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.297876,-99) , 
8, 24.1961, -2.69996, 0, -0.209841, 0.212024, 0, 0, -21.484, 7, -0.0374246, 0, 0, 0.497796,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0291009, 1, 0, 0.504587,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.47008,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0459058, 0, 0, 0.503009,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0208521);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.608727,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.470381,-99) , 
8, -1378.23, -1632.98, -680008, 0, 0, 0.996958, 0.590692, 3011.23, 7, 0.0188501, 0, 0, 0.530383,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.500014,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.429205,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0600095, 1, 0, 0.496664,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.409305,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.366021, 1, 0, 0.493151,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.60174, 0, 0, 0.495467,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0327425);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.616791,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.430972,-99) , 
8, -1356.89, -1640.3, -677398, 0, 0, 0.940963, 0.563772, 2997.19, 7, 0.00797931, 0, 0, 0.531115,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.366021, 1, -1, 0.488829,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.60174, 0, 0, 0.491457,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0358761);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.583519,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.550163,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.382683,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0201717, 1, 0, 0.48453,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0510973, 1, 0, 0.522316,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.502743,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.417305,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0374858, 1, 0, 0.499867,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.405418,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0572129, 0, 0, 0.495807,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.336596, 0, 0, 0.499093,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0458293);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.574775,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.590066,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.347104,-99) , 
8, 0, 0, 0, 0.386723, -0.68472, 0, 0, 0.0822564, 7, -0.00803859, 0, 0, 0.482543,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0510973, 1, 0, 0.517744,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.289019, 1, -1, 0.488184,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.336596, 0, 0, 0.49184,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.115814);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.67881,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.461068,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0430996, 0, 0, 0.565938,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.565994,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.440909,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.101409, 1, 0, 0.481585,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0279785, 1, 0, 0.513959,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.555424,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.444892,-99) , 
8, 993.853, -687.204, 0, -2.21223, 2.09853, 1.28654, 0, -306.611, 7, -0.00362186, 0, 0, 0.515253,-99) , 
NN(
0, 
0, 
8, 0, 0, 0, -0.109732, 0.137472, 0, 0, 0.00682237, -1, 0.00539081, 1, -1, 0.458335,-99) , 
8, 24.3748, -2.75026, 0, -0.366879, 0.406268, 0, 0, -21.6115, 7, 0.00275057, 0, 0, 0.497187,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0171853, 0, 0, 0.501239,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0679937);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.00808039, 0, 1, 0.54484,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.52198,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.398107,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0154208, 0, 0, 0.491934,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00088408, 1, 0, 0.519697,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.633356,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.511138,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.441059,-99) , 
8, 0, 0, 0, 0.632528, -0.47501, 0, 0, -0.0276046, 7, -0.0138386, 0, 0, 0.492082,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.0167743, 1, 0, 0.498838,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.243949, 0, 0, 0.505753,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0530958);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.688316,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.485082,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.00808039, 0, 0, 0.527933,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.504995,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.414507,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0154208, 0, 0, 0.483137,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00088408, 1, 0, 0.506642,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.617429,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0193357, 0, -1, 0.484305,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.0167743, 1, 0, 0.490627,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.243949, 0, 0, 0.495933,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0631165);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.51947,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.386914,-99) , 
8, 622.112, -59.416, 0, 0.215004, -0.350019, 0, 0, -562.676, 7, -0.0441604, 0, 0, 0.51356,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.344947,-99) , 
8, 24.042, -2.55421, 0, 0.228746, -0.322268, 0, 0, -21.4823, 7, -0.0308641, 0, 0, 0.508416,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.536841,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.451841,-99) , 
8, 935.65, 2205.86, 59157.6, -0.366882, 0.362276, 0, 0, -3141.46, 7, 0.00310628, 0, 0, 0.504892,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.396913,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.214182, 0, 0, 0.47556,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.024279, 1, 0, 0.504224,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0960071);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.538926,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.375124,-99) , 
8, 2147.03, 5.20976, 0, 0.0152925, 0.0387185, 0, 0, -2152.23, 7, -0.0110449, 0, 0, 0.512049,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.550597,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.401562,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0335518, 1, 0, 0.447086,-99) , 
8, 25.6288, -3.08967, 0, 0.242076, -0.279192, 0, 0, -22.5435, 7, -0.00837145, 0, 0, 0.500159,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.525517,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.466477,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0207329, 1, 0, 0.492251,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.398402,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0858936, 0, 0, 0.484429,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00088408, 1, 0, 0.49266,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0651232);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.608481,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.490448,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.00216547, 0, 0, 0.519576,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.52857,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.359918,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0204145, 0, 0, 0.423161,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0078439, 1, 0, 0.497993,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.502955,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.436431,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.538356, 1, 0, 0.496404,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.183946, 1, -1, 0.461291,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.238414, 0, 0, 0.482248,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.124686, 1, 0, 0.488898,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0583433);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0167706, 1, 1, 0.52788,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.512318,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.375054,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0204145, 0, 0, 0.426761,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0078439, 1, 0, 0.505318,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.0501464, 0, -1, 0.486901,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.510286,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.331381,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.467683, 0, 0, 0.449413,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.36952, 1, 0, 0.480983,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.124686, 1, 0, 0.49125,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0574177);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.515192,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.440893,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0384784, 0, 0, 0.504449,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.531272,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.452289,-99) , 
8, 70.3855, -15.416, 0, 0.275724, -0.327261, 0, 0, -54.978, 7, 0.00731893, 0, 0, 0.473227,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.00806636, 0, 0, 0.495582,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.453472,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0476739, 1, 0, 0.493472,-99)    );
   return;
};

// Clean up
inline void ReadBDTF::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDTF::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
