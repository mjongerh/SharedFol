// Class: ReadBDTF
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTF
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.24/06       [399366]
Creator        : mjongerh
Date           : Wed Feb 23 15:04:19 2022
Host           : Linux alicecerno2 5.4.0-90-generic #101-Ubuntu SMP Fri Oct 15 20:00:55 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/mjongerh/alice/SharedFol/CERN/Lb
Training events: 49456
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
UseFisherCuts: "True" [Use multivariate splits using the Fisher criterion]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 7
fCPA                          fCPA                          fCPA                          fCPA                          units                             'F'    [0.950000166893,1]
fCPAXY                        fCPAXY                        fCPAXY                        fCPAXY                        units                             'F'    [-0.999749720097,1]
fChi2PCA                      fChi2PCA                      fChi2PCA                      fChi2PCA                      units                             'F'    [7.12091582488e-18,9.99586191028e-05]
fDecayLength                  fDecayLength                  fDecayLength                  fDecayLength                  units                             'F'    [0.00500783696771,24.5316181183]
fDecayLengthXY                fDecayLengthXY                fDecayLengthXY                fDecayLengthXY                units                             'F'    [0.00500002177432,20.8340053558]
fImpactParameter0             fImpactParameter0             fImpactParameter0             fImpactParameter0             units                             'F'    [-0.176397100091,0.169094100595]
fImpactParameter1             fImpactParameter1             fImpactParameter1             fImpactParameter1             units                             'F'    [-2.77989411354,2.03893828392]
NSpec 4
fPtProng0                     fPtProng0                     fPtProng0                     fPtProng0                     units                             'F'    [0.500036478043,5.51516151428]
fPtProng1                     fPtProng1                     fPtProng1                     fPtProng1                     units                             'F'    [0.50001001358,4.91962242126]
fM                            fM                            fM                            fM                            units                             'F'    [4.6202545166,6.62003850937]
fPt                           fPt                           fPt                           fPt                           Gev                               'F'    [3.000010252,3.99999690056]


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTFNode

#ifndef BDTFNode__def
#define BDTFNode__def

class BDTFNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDTFNode ( BDTFNode* left,BDTFNode* right,
                          int nFisherCoeff,
                          double fisherCoeff0,
                          double fisherCoeff1,
                          double fisherCoeff2,
                          double fisherCoeff3,
                          double fisherCoeff4,
                          double fisherCoeff5,
                          double fisherCoeff6,
                          double fisherCoeff7,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fNFisherCoeff ( nFisherCoeff ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
     fFisherCoeff.push_back(fisherCoeff0);
     fFisherCoeff.push_back(fisherCoeff1);
     fFisherCoeff.push_back(fisherCoeff2);
     fFisherCoeff.push_back(fisherCoeff3);
     fFisherCoeff.push_back(fisherCoeff4);
     fFisherCoeff.push_back(fisherCoeff5);
     fFisherCoeff.push_back(fisherCoeff6);
     fFisherCoeff.push_back(fisherCoeff7);
   }

   virtual ~BDTFNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTFNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTFNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTFNode*   fLeft;     // pointer to the left daughter node
   BDTFNode*   fRight;    // pointer to the right daughter node
   int                     fNFisherCoeff; // =0 if this node doesn't use fisher, else =nvar+1 
   std::vector<double>     fFisherCoeff;  // the fisher coeff (offset at the last element)
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTFNode::~BDTFNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTFNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
   if (fNFisherCoeff == 0){
     result = (inputValues[fSelector] >= fCutValue );
   }else{
     double fisher = fFisherCoeff.at(fFisherCoeff.size()-1);
     for (unsigned int ivar=0; ivar<fFisherCoeff.size()-1; ivar++)
       fisher += fFisherCoeff.at(ivar)*inputValues.at(ivar);
     result = fisher > fCutValue;
   }
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTFNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTF : public IClassifierReader {

 public:

   // constructor
   ReadBDTF( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDTF" ),
        fNvars( 7 )
   {
      // the training input variables
      const char* inputVars[] = { "fCPA", "fCPAXY", "fChi2PCA", "fDecayLength", "fDecayLengthXY", "fImpactParameter0", "fImpactParameter1" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTF() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[7];
   double fVmax[7];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[7];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTFNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTF::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTFNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTFNode*)current->GetRight();
         else current=(BDTFNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDTF::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(0.531175749382685);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.99989, 0, 1, 0.748575,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.534784,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.281908,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00959622, 1, 0, 0.499429,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999887, 0, 0, 0.649978,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.995351, 0, -1, 0.0495264,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.997619, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.387315);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.999957, 0, 1, 0.612788,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.00438114, 0, -1, 0.371802,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999773, 0, 0, 0.53217,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.99093, 0, -1, 0.0196729,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.995238, 0, 0, 0.438013,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.256795);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.54836,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.383243,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0432008, 0, 0, 0.538083,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.999774, 0, -1, 0.428284,-99) , 
8, 0, 0, 0, -0.738599, 0.775878, 0.91265, -0.0622639, 0.0184016, 7, 0.00132235, 0, 0, 0.500546,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.986621, 0, -1, 0.0287115,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.995238, 0, 0, 0.424413,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.289793);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.59072,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.441004,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999957, 0, 0, 0.516121,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.00623253, 1, -1, 0.376595,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999547, 0, 0, 0.485363,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.986621, 0, -1, 0.0368082,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.995238, 0, 0, 0.419588,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.184354);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.523327,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.354685,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0283294, 0, 0, 0.515006,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.99655, 0, -1, 0.416067,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.99932, 0, 0, 0.497759,-99) , 
NN(
0, 
0, 
8, 8.37849, 0, 0, -1.39142, 1.42977, -1.3524, 0.028064, -8.17916, -1, -0.0452373, 0, -1, 0.0216377,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.441118,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.15686);
  fForest.push_back( 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.992857, 0, -1, 0.422207,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.171723);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.537835,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.473097,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0071776, 0, 0, 0.520284,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.384952,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0210264, 1, 0, 0.510546,-99) , 
NN(
0, 
0, 
8, 9.85042, 0, 0, -1.63587, 1.68095, -1.58999, 0.0329943, -9.61607, -1, -0.0531846, 0, -1, 0.0301713,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.460865,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.167642);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.524825,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.367599,-99) , 
8, 0, 0, 0, -0.659428, -2.40542, -0.862715, 1.34133, 0.0752863, 7, -0.0777841, 0, 0, 0.509641,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0210264, 0, -1, 0.420176,-99) , 
8, 0, 0, 0, -0.512683, 0.512472, -0.874297, 0.13205, 0.0127623, 7, -0.0165624, 0, 0, 0.495402,-99) , 
NN(
0, 
0, 
8, 10.6732, 0, 0, -1.77251, 1.82136, -1.7228, 0.0357503, -10.4193, -1, -0.0576271, 0, -1, 0.0356225,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.451032,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.144459);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.613798,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.47416,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.997733, 1, 0, 0.478517,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.307426,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.996599, 0, 0, 0.473502,-99) , 
NN(
0, 
0, 
8, 11.5315, 0, 0, -1.91504, 1.96782, -1.86133, 0.038625, -11.2571, -1, -0.0622609, 0, -1, 0.041852,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.434541,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.128638);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.528675,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.484284,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999838, 0, 0, 0.51237,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.339007,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.996599, 0, 0, 0.507406,-99) , 
NN(
0, 
0, 
8, 12.3151, 0, 0, -2.04518, 2.10154, -1.98782, 0.0412498, -12.0221, -1, -0.0664919, 0, -1, 0.0480439,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.468278,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0860292);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.997733, 1, 1, 0.503859,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.3684,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.996599, 0, 0, 0.500046,-99) , 
NN(
0, 
0, 
8, 13.0472, 0, 0, -2.16675, 2.22647, -2.10598, 0.0437019, -12.7368, -1, -0.0704445, 0, -1, 0.0542813,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.463984,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.116675);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.589393,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.478941,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.997733, 1, 0, 0.482359,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.388634,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.996599, 0, 0, 0.479749,-99) , 
NN(
0, 
0, 
8, 13.5545, 0, 0, -2.25101, 2.31305, -2.18788, 0.0454013, -13.2321, -1, -0.0731839, 0, -1, 0.0588707,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.446884,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0943916);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.517903,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.493786,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00457448, 1, 0, 0.509718,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.416689,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.996599, 0, 0, 0.507153,-99) , 
NN(
0, 
0, 
8, 14.2649, 0, 0, -2.36897, 2.43427, -2.30253, 0.0477806, -13.9255, -1, -0.0770191, 0, -1, 0.0656777,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.474229,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0891834);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.509311,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.46761,-99) , 
8, 0, 0, 0, -0.392284, 0.383213, -0.544359, -0.410868, 0.00928695, 7, -0.00977548, 0, 0, 0.503133,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.438181,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0283294, 0, 0, 0.500439,-99) , 
NN(
0, 
0, 
8, 14.8577, 0, 0, -2.46742, 2.53543, -2.39822, 0.0497662, -14.5042, -1, -0.0802197, 0, -1, 0.0717129,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.469639,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0954633);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.506524,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.475268,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999935, 0, 0, 0.491094,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.997538, 1, -1, 0.44039,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.99864, 0, 0, 0.486317,-99) , 
NN(
0, 
0, 
8, 15.4319, 0, 0, -2.56279, 2.63343, -2.49092, 0.0516898, -15.0648, -1, -0.0833204, 0, -1, 0.0778814,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.457982,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0866143);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.509268,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.48287,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.99966, 1, 0, 0.490024,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.446957,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0283294, 0, 0, 0.488267,-99) , 
NN(
0, 
0, 
8, 16.0611, 0, 0, -2.66728, 2.74079, -2.59247, 0.0537971, -15.679, -1, -0.0867173, 0, -1, 0.0850194,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.461297,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0806508);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.531008,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.496093,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999741, 1, 0, 0.504449,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.997538, 1, -1, 0.442955,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.99864, 0, 0, 0.498656,-99) , 
NN(
0, 
0, 
8, 16.6439, 0, 0, -2.76406, 2.84025, -2.68654, 0.0557493, -16.2479, -1, -0.0898641, 0, -1, 0.0920039,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.472336,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.110109);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.569154,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.499095,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999984, 0, 0, 0.522667,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.518844,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.343235,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.00438114, 0, 0, 0.474937,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.99966, 0, 0, 0.510082,-99) , 
NN(
0, 
0, 
8, 17.1959, 0, 0, -2.85574, 2.93445, -2.77564, 0.0575982, -16.7868, -1, -0.0928445, 0, -1, 0.0989667,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.992857, 0, 0, 0.484265,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.155712);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.53209,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.423509,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.99926, 0, 0, 0.527219,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.577812,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.197608,-99) , 
8, 0, 0, 0, -2.64725, 2.90241, 0.943447, -0.428406, 0.0164835, 7, 0.00377074, 0, 0, 0.445824,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999433, 0, 0, 0.510826,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0663557,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.988095, 0, 0, 0.488733,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.117908);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.51236,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.398596,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1.0788e-07, 1, 0, 0.497772,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0943533,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4.53169e-07, 1, 0, 0.477965,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4.75993e-06, 1, 0, 0.461086,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.114406);
  fForest.push_back( 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 4.75993e-06, 1, -1, 0.443045,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0925555);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.510139,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.418289,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1.72609e-07, 1, 0, 0.504395,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.116162,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4.53169e-07, 1, 0, 0.486893,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4.75993e-06, 1, 0, 0.47143,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.107472);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.575418,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.47875,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.997619, 1, 0, 0.484143,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.126007,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4.53169e-07, 1, 0, 0.468526,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4.75993e-06, 1, 0, 0.454273,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0821335);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.510659,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.429032,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2.37337e-07, 1, 0, 0.508011,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.138326,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4.53169e-07, 1, 0, 0.492472,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4.75993e-06, 1, 0, 0.478213,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0768226);
  fForest.push_back( 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 4.75993e-06, 1, -1, 0.461664,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0734013);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.509677,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.435557,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2.26501e-07, 1, 0, 0.506278,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0941576,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 6.79754e-07, 1, 0, 0.494079,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4.75993e-06, 1, 0, 0.480804,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.069137);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.500451,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.473126,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3.23573e-08, 1, 0, 0.489609,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.100607,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 6.79754e-07, 1, 0, 0.478418,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4.75993e-06, 1, 0, 0.466001,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0731848);
  fForest.push_back( 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 4.75993e-06, 1, -1, 0.463473,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0578099);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.507206,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.466952,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999611, 0, 0, 0.498404,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.392723,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.995919, 0, 0, 0.49533,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0674497,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.985714, 0, 0, 0.481712,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0603594);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.508031,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.481384,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999806, 1, 0, 0.490267,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.406592,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.995919, 0, 0, 0.487846,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0711781,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.985714, 0, 0, 0.474895,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0541174);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.503408,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.452915,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999611, 0, 0, 0.498898,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.511292,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.363308,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00260863, 1, 0, 0.464513,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.99932, 0, 0, 0.493158,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0752734,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.985714, 0, 0, 0.480482,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.057924);
  fForest.push_back( 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.985714, 0, -1, 0.47107,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0343124);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.501478,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.454794,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0283294, 0, 0, 0.499548,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.429025,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.995919, 0, 0, 0.497533,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.083453,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.985714, 0, 0, 0.485523,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0626077);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.526492,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.486823,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999773, 1, 0, 0.494475,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.507041,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.38371,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00260863, 1, 0, 0.468378,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.99932, 0, 0, 0.490133,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0861153,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.985714, 0, 0, 0.478575,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0541166);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.508715,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.456912,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999611, 0, 0, 0.504089,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.00260863, 1, -1, 0.462444,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.99932, 0, 0, 0.49717,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0911718,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.985714, 0, 0, 0.485835,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0471779);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.548149,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.489625,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.997668, 1, 0, 0.49151,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.443261,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.995919, 0, 0, 0.490145,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0957562,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.985714, 0, 0, 0.479361,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0362934);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.513895,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.499012,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00457448, 0, 0, 0.504221,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.997408, 1, -1, 0.472544,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.99864, 0, 0, 0.501199,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0999198,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.985714, 0, 0, 0.490424,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.037675);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.0118775, 1, 1, 0.506944,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.504867,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.452867,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.997408, 1, 0, 0.481598,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.99864, 0, 0, 0.504527,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.103232,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.985714, 0, 0, 0.493902,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0334005);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.540204,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.495681,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.997668, 1, 0, 0.497114,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.45459,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.995919, 0, 0, 0.495912,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.106772,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.985714, 0, 0, 0.485755,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.037417);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.508299,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.492814,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999611, 0, 0, 0.504927,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.462883,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.995919, 0, 0, 0.50374,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.109999,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.985714, 0, 0, 0.493592,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0474061);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.531116,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.497306,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.99932, 1, 0, 0.504027,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.509416,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.417728,-99) , 
8, 42.9998, 1.03237, 0, -0.320238, 0.244562, 0, 0.843634, -43.9816, 7, -0.0106472, 0, 0, 0.488614,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00457448, 1, 0, 0.498874,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.113716,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.985714, 0, 0, 0.489085,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0457654);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.997166, 1, 1, 0.511419,-99) , 
NN(
0, 
0, 
8, 37.529, 2.12979, 0, -0.247845, 0.165019, 0, 0.644649, -39.6177, -1, -0.0060023, 0, -1, 0.482869,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00457448, 1, 0, 0.501862,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.148128,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.988095, 0, 0, 0.491898,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0347364);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.519357,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.495681,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0118775, 1, 0, 0.499841,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.997328, 1, -1, 0.483612,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.998866, 0, 0, 0.49808,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.153996,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.988095, 0, 0, 0.488535,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0379632);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.507569,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.461484,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0280793, 1, 0, 0.505662,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.465704,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0283294, 0, 0, 0.504044,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.158576,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.988095, 0, 0, 0.49457,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0375719);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.513446,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.492373,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999784, 1, 0, 0.497657,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.997328, 1, -1, 0.483075,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.998866, 0, 0, 0.496075,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.163707,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.988095, 0, 0, 0.487071,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0349741);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.526695,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.498462,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0118775, 1, 0, 0.503712,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.508061,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.453802,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00260863, 1, 0, 0.490718,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999433, 0, 0, 0.501269,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.168916,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.988095, 0, 0, 0.492373,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0363902);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.00457448, 0, 1, 0.509205,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.00260863, 1, -1, 0.487555,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999433, 0, 0, 0.505136,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.173883,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.988095, 0, 0, 0.496367,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0279807);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.503242,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.48883,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.00952469, 0, 0, 0.500871,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.466045,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0283294, 0, 0, 0.499458,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.179173,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.988095, 0, 0, 0.491075,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.025718);
  fForest.push_back( 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.988095, 0, -1, 0.487144,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0258762);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.50363,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.478889,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0280793, 1, 0, 0.502607,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.479429,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0283294, 0, 0, 0.501668,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.187207,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.988095, 0, 0, 0.493571,-99)    );
   return;
};

// Clean up
inline void ReadBDTF::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDTF::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
