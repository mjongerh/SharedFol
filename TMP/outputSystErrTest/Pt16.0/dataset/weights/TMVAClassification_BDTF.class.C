// Class: ReadBDTF
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTF
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.24/06       [399366]
Creator        : mjongerh
Date           : Wed Feb 23 15:19:07 2022
Host           : Linux alicecerno2 5.4.0-90-generic #101-Ubuntu SMP Fri Oct 15 20:00:55 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/mjongerh/alice/SharedFol/CERN/Lb
Training events: 7935
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
UseFisherCuts: "True" [Use multivariate splits using the Fisher criterion]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 7
fCPA                          fCPA                          fCPA                          fCPA                          units                             'F'    [0.950181782246,1]
fCPAXY                        fCPAXY                        fCPAXY                        fCPAXY                        units                             'F'    [0.755708694458,1]
fChi2PCA                      fChi2PCA                      fChi2PCA                      fChi2PCA                      units                             'F'    [4.60229952056e-16,9.97138340608e-05]
fDecayLength                  fDecayLength                  fDecayLength                  fDecayLength                  units                             'F'    [0.0054257879965,1.90096282959]
fDecayLengthXY                fDecayLengthXY                fDecayLengthXY                fDecayLengthXY                units                             'F'    [0.00500084972009,1.33855259418]
fImpactParameter0             fImpactParameter0             fImpactParameter0             fImpactParameter0             units                             'F'    [-0.277927190065,0.292718052864]
fImpactParameter1             fImpactParameter1             fImpactParameter1             fImpactParameter1             units                             'F'    [-1.15644061565,1.20091342926]
NSpec 4
fPtProng0                     fPtProng0                     fPtProng0                     fPtProng0                     units                             'F'    [1.69647455215,20.0532665253]
fPtProng1                     fPtProng1                     fPtProng1                     fPtProng1                     units                             'F'    [0.501850187778,17.9498252869]
fM                            fM                            fM                            fM                            units                             'F'    [4.62373113632,6.61093950272]
fPt                           fPt                           fPt                           fPt                           Gev                               'F'    [16.0004367828,19.9995918274]


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTFNode

#ifndef BDTFNode__def
#define BDTFNode__def

class BDTFNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDTFNode ( BDTFNode* left,BDTFNode* right,
                          int nFisherCoeff,
                          double fisherCoeff0,
                          double fisherCoeff1,
                          double fisherCoeff2,
                          double fisherCoeff3,
                          double fisherCoeff4,
                          double fisherCoeff5,
                          double fisherCoeff6,
                          double fisherCoeff7,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fNFisherCoeff ( nFisherCoeff ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
     fFisherCoeff.push_back(fisherCoeff0);
     fFisherCoeff.push_back(fisherCoeff1);
     fFisherCoeff.push_back(fisherCoeff2);
     fFisherCoeff.push_back(fisherCoeff3);
     fFisherCoeff.push_back(fisherCoeff4);
     fFisherCoeff.push_back(fisherCoeff5);
     fFisherCoeff.push_back(fisherCoeff6);
     fFisherCoeff.push_back(fisherCoeff7);
   }

   virtual ~BDTFNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTFNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTFNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTFNode*   fLeft;     // pointer to the left daughter node
   BDTFNode*   fRight;    // pointer to the right daughter node
   int                     fNFisherCoeff; // =0 if this node doesn't use fisher, else =nvar+1 
   std::vector<double>     fFisherCoeff;  // the fisher coeff (offset at the last element)
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTFNode::~BDTFNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTFNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
   if (fNFisherCoeff == 0){
     result = (inputValues[fSelector] >= fCutValue );
   }else{
     double fisher = fFisherCoeff.at(fFisherCoeff.size()-1);
     for (unsigned int ivar=0; ivar<fFisherCoeff.size()-1; ivar++)
       fisher += fFisherCoeff.at(ivar)*inputValues.at(ivar);
     result = fisher > fCutValue;
   }
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTFNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTF : public IClassifierReader {

 public:

   // constructor
   ReadBDTF( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDTF" ),
        fNvars( 7 )
   {
      // the training input variables
      const char* inputVars[] = { "fCPA", "fCPAXY", "fChi2PCA", "fDecayLength", "fDecayLengthXY", "fImpactParameter0", "fImpactParameter1" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTF() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[7];
   double fVmax[7];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[7];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTFNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTF::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTFNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTFNode*)current->GetRight();
         else current=(BDTFNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDTF::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(0.275562393194199);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.600416,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.372108,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999989, 0, 0, 0.543705,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.999672, 0, -1, 0.195186,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999887, 0, 0, 0.514481,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.997628, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.236364);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.58372,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.260709,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999887, 0, 0, 0.546282,-99) , 
NN(
0, 
0, 
8, 0, 0, 0, 0.178003, -0.662189, 0, 0, 0.113154, -1, -0.0782695, 0, -1, 0.386272,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.186076, 1, 0, 0.488264,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.997628, 0, 0, 0.475949,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.12098);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.621231,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.465311,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.00177793, 0, 0, 0.580675,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.259587, 1, -1, 0.453984,-99) , 
8, 0, 0, 0, 0.159606, -0.478594, 0, 0, 0.033329, 7, 0.0260529, 0, 0, 0.475383,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.244058,-99) , 
8, 0, 0, 0, 0.203623, -0.620422, 0, 0, 0.0483338, 7, -0.125034, 0, 0, 0.46931,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.0664791);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.591293,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.493764,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.0247537, 1, 0, 0.55382,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.273955, 1, -1, 0.483331,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.0395774, 1, 0, 0.499932,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.324338,-99) , 
8, 0, 0, 0, 0.193329, -0.557409, 0, 0, 0.0415632, 7, -0.0857339, 0, 0, 0.492108,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.0603684);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.571736,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.489562,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.00203051, 0, 0, 0.550169,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.509327,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.468467,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.273955, 1, 0, 0.499933,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.039611, 1, 0, 0.511739,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.339199,-99) , 
8, 0, 0, 0, 0.189427, -0.520566, 0, 0, 0.0371751, 7, -0.0771904, 0, 0, 0.504127,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.062823);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.557107,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.456558,-99) , 
8, 0, 0, 0, -2.93635, 1.69031, 0, 0, 0.0562691, 7, -0.0181693, 0, 0, 0.534539,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.549328,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.487705,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0397343, 0, 0, 0.492624,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.0465832, 1, 0, 0.503855,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.289178,-99) , 
8, 0, 0, 0, 0.222621, -0.507832, 0, 0, 0.0290977, 7, -0.0746055, 0, 0, 0.497217,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.0636776);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.536459,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.467095,-99) , 
8, 0, 0, 0, -0.388685, 0.75828, 0, 0, -0.00346505, 7, -0.00456593, 0, 0, 0.526827,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.568948,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.487154,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0438278, 1, 0, 0.500812,-99) , 
8, 0, 0, 0, 0.0881046, -0.155614, 0, 0, 0.00414637, 7, 0.00240087, 0, 0, 0.510817,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.375619,-99) , 
8, 0, 0, 0, 0.215179, -0.472996, 0, 0, 0.0256176, 7, -0.0585718, 0, 0, 0.504826,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.069872);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.534519,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.404485,-99) , 
8, 0, 0, 0, 0.182714, -0.45062, 0, 0, 0.0230276, 7, -0.0364418, 0, 0, 0.524793,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.603236,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.488319,-99) , 
8, 0, 0, 0, -0.144577, 0.432647, 0, 0, -0.0315929, 7, 0.0387617, 0, 0, 0.50051,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00099643, 1, 0, 0.513319,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.355431,-99) , 
8, 0, 0, 0, 0.171422, -0.3842, 0, 0, 0.0214187, 7, -0.0522893, 0, 0, 0.507555,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0515002);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.603792,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.48242,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00099643, 0, 0, 0.553031,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.514609,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.416449,-99) , 
8, 0, 0, 0, 0.0376676, -0.138119, 0, 0, 0.00949885, 7, -0.0143554, 0, 0, 0.509481,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.33766, 0, 0, 0.512212,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.310076,-99) , 
8, 0, 0, 0, 0.14219, -0.329267, 0, 0, 0.0191974, 7, -0.0514504, 0, 0, 0.506926,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0317676);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.6177,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.56287,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.494992,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0418874, 0, 0, 0.498245,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.373066,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.547008, 1, 0, 0.492959,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.496608,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0403105);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.00099643, 0, 1, 0.557286,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.509709,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.438083,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.258276, 1, 0, 0.50508,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.33766, 0, 0, 0.508325,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.319203,-99) , 
8, 0, 0, 0, 0.116819, -0.269933, 0, 0, 0.0156476, 7, -0.0418717, 0, 0, 0.503379,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0379826);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.607789,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.50605,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.475964,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.00827095, 0, 0, 0.496617,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.378046,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.547008, 1, 0, 0.491636,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.495015,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.245152);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.594347,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.395657,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999995, 0, 0, 0.526533,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.999672, 0, -1, 0.234886,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.999887, 0, 0, 0.504443,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.997628, 0, 0, 0.491827,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.103127);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.550583,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.435361,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.00622596, 1, 0, 0.537683,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0824225, 0, -1, 0.394963,-99) , 
8, 0, 0, 0, -3.03685, 1.93637, 0, 0, 0.0699001, 7, -0.0468285, 0, 0, 0.517792,-99) , 
NN(
0, 
0, 
8, 0, 0, 0, 0.0922461, -0.297585, 0, 0, 0.0353563, -1, -0.0509004, 0, -1, 0.45413,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.0956895, 1, 0, 0.479822,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0503242);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.543659,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.462182,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.00203051, 0, 0, 0.522333,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0725767, 0, -1, 0.48435,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.0395774, 1, 0, 0.493282,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.348387,-99) , 
8, 0, 0, 0, 0.0837514, -0.284538, 0, 0, 0.0237139, 7, -0.0610511, 0, 0, 0.489636,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.03455);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.565957,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.449596,-99) , 
8, 0, 0, 0, -0.177524, 0.135243, 0, 0, 0.023578, 7, -0.00624041, 0, 0, 0.539967,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.31619, 1, -1, 0.495627,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.03522, 1, 0, 0.502518,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.398486,-99) , 
8, 0, 0, 0, 0.079936, -0.250808, 0, 0, 0.0197718, 7, -0.0410722, 0, 0, 0.497954,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0417878);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0521496, 0, 1, 0.512681,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.561236,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.435546,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.062196, 0, 0, 0.47471,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.0248936, 0, 0, 0.508895,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.409862,-99) , 
8, 0, 0, 0, 0.0902355, -0.268783, 0, 0, 0.0203355, 7, -0.0425679, 0, 0, 0.504601,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0341493);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.546132,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.447072,-99) , 
8, 0, 0, 0, -0.140447, 0.115133, 0, 0, 0.0169611, 7, -0.00554509, 0, 0, 0.525027,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.501941,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.456149,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0147509, 0, 0, 0.496049,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.03522, 1, 0, 0.500536,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.404452,-99) , 
8, 0, 0, 0, 0.0714712, -0.220106, 0, 0, 0.0170768, 7, -0.0356674, 0, 0, 0.496429,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0284437);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.58897,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.0817468, 0, -1, 0.488011,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.490934,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0230784);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.582068,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.502433,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.398654,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.42944, 1, 0, 0.499337,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.37664,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0817468, 0, 0, 0.49512,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.497631,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0318919);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.551685,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.581399,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.49065,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0469692, 0, 0, 0.49394,-99) , 
8, 0, 0, 0, 0.00666292, 0.00479779, 0, 0, -0.00170129, 7, 0.00393572, 0, 0, 0.495705,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.420835,-99) , 
8, 0, 0, 0, 0.0690716, -0.192112, 0, 0, 0.0136429, 7, -0.0289882, 0, 0, 0.492568,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0427744);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.571876,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.429706,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -0.00106463, 0, 0, 0.527021,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.554102,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.494851,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.339656, 0, 0, 0.497919,-99) , 
8, 0, 0, 0, -0.036947, 0.0156685, 0, 0, 0.00377129, 7, 0.00288087, 0, 0, 0.503086,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.0338911, 1, -1, 0.436016,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.547008, 1, 0, 0.499536,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0576957);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, 0, 0, 0, 0.78402, -1.82252, 0, 0, 0.123552, -1, 0.00355408, 0, 1, 0.579687,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.511717,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.411229,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0283113, 0, 0, 0.507346,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0413358, 1, 0, 0.514266,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.605558,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.46772,-99) , 
8, 9318.43, -2763.25, 0, -0.159276, 0.690578, 0, 0, -6555.3, 7, 0.0423286, 0, 0, 0.499297,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.415205,-99) , 
8, 141.66, -57.7673, 0, 0.0942988, -0.266974, 0, 0, -83.8469, 7, -0.0113941, 0, 0, 0.478723,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.276217, 1, 0, 0.506911,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0197189);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.591473,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.501592,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.41933,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.42944, 1, 0, 0.499167,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.393067,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0817468, 0, 0, 0.495553,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.498323,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0364872);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.562809,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.529496,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.489636,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0410154, 1, 0, 0.494421,-99) , 
8, 0, 0, 0, -0.0870577, 0.221179, 0, 0, -0.0119323, 7, 0.0214789, 0, 0, 0.497783,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.437106, 0, -1, 0.426035,-99) , 
8, 0, 0, 0, 0.0745018, -0.148341, 0, 0, 0.00659573, 7, -0.0144629, 0, 0, 0.493991,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.02221);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.559522,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.502931,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.416859,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.293509, 1, 0, 0.499745,-99) , 
8, 0, 0, 0, -0.00471208, 0.0465859, 0, 0, -0.00504962, 7, 0.00897558, 0, 0, 0.502949,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.408449,-99) , 
8, 0, 0, 0, 0.067849, -0.155449, 0, 0, 0.00879894, 7, -0.0234139, 0, 0, 0.500291,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0185608);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.581812,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.0817468, 0, -1, 0.492869,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.495428,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0211119);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.57729,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.503247,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.433866,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.42944, 1, 0, 0.501213,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.392338,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0817468, 0, 0, 0.497509,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.499801,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0310992);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.57213,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.519182,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.491126,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0206272, 1, 0, 0.496244,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.397383,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0817468, 0, 0, 0.492888,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.495161,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0193037);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.5645,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.503201,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.449149,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.547008, 1, 0, 0.501182,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.404853,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0817468, 0, 0, 0.497921,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.499828,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0262582);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.558515,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.570114,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.492792,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0484346, 0, 0, 0.495567,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.599241, 0, 0, 0.497836,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.428938,-99) , 
8, 0, 0, 0, 0.0669726, -0.140245, 0, 0, 0.00686485, 7, -0.0184945, 0, 0, 0.495657,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0262791);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.569353,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.505129,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.368233,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.380866, 1, 0, 0.501147,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.443836, 0, 0, 0.50395,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.0338911, 1, -1, 0.453297,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.547008, 1, 0, 0.501323,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0155699);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.562328,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.0817468, 0, -1, 0.493822,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.495781,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0225247);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.554556,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.555065,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.495811,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0466125, 0, 0, 0.498669,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0784653, 0, 0, 0.501767,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.429638,-99) , 
8, 0, 0, 0, 0.0647057, -0.135072, 0, 0, 0.00656786, 7, -0.0175353, 0, 0, 0.499451,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0361515);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.562243,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.510667,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.439956,-99) , 
8, 0, 0, 0, 0.0328507, -0.0833452, 0, 0, 0.00493161, 7, 0.00435966, 1, 0, 0.505245,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.416818,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0817468, 0, 0, 0.502267,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.503982,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0190009);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.553327,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.501913,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.452972,-99) , 
8, 0, 0, 0, 0.0120387, -0.0272472, 0, 0, 0.00134399, 7, 0.0012118, 1, 0, 0.498133,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.4252,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.547008, 1, 0, 0.495175,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.496835,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0234684);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.548003,-99) , 
NN(
0, 
0, 
8, 0, 0, 0, -0.0392791, 0.0254406, 0, 0, 0.00318342, -1, -0.00394063, 0, -1, 0.493266,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0784653, 0, 0, 0.496198,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.437575,-99) , 
8, 0, 0, 0, 0.0764591, -0.162709, 0, 0, 0.00818512, 7, -0.0169143, 0, 0, 0.493142,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0194046);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.549195,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.502273,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.458757,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.254495, 1, 0, 0.499599,-99) , 
8, 0, 0, 0, -0.0254973, 0.0580422, 0, 0, -0.00259605, 7, 0.0051855, 0, 0, 0.501243,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.519854,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.402651,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0338911, 1, 0, 0.457602,-99) , 
8, 0, 0, 0, 0.072042, -0.161123, 0, 0, 0.0087805, 7, -0.0157123, 0, 0, 0.498413,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0192525);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.552207,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0290085, 1, -1, 0.495106,-99) , 
8, 0, 0, 0, -0.0137122, 0.0643907, 0, 0, -0.00539903, 7, 0.00972027, 0, 0, 0.497449,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.436603, 0, -1, 0.439969,-99) , 
8, 0, 0, 0, 0.080102, -0.159367, 0, 0, 0.00705306, 7, -0.015472, 0, 0, 0.494434,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0119997);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.555192,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.500941,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.455291,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.42944, 1, 0, 0.499619,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.427833,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0817468, 0, 0, 0.497215,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.498872,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.02779);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.552227,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.505552,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.478153,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.00827095, 0, 0, 0.497045,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.435952,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.547008, 1, 0, 0.494584,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.496231,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0199303);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.557314,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.372783, 1, -1, 0.493918,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.599241, 0, 0, 0.496132,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.448783,-99) , 
8, 0, 0, 0, 0.0741946, -0.139365, 0, 0, 0.00540429, 7, -0.0132305, 0, 0, 0.493847,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0330881);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.55657,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.50818,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.472007,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0153347, 1, 0, 0.499441,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.599241, 0, 0, 0.501267,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.506012,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.409519,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0209822, 0, 0, 0.454094,-99) , 
8, 0, 0, 0, 0.0597007, -0.125501, 0, 0, 0.0061752, 7, -0.0120339, 0, 0, 0.498497,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.017396);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.531072,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0325686, 1, -1, 0.492471,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0481558, 0, 0, 0.494387,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0121741);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.118989, 1, 1, 0.539585,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.0305128, 0, -1, 0.497248,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0784653, 0, 0, 0.499657,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.446211,-99) , 
8, 0, 0, 0, 0.0473831, -0.101671, 0, 0, 0.00518131, 7, -0.0150419, 0, 0, 0.498304,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0220485);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.571539,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.50365,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.378114,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.380866, 1, 0, 0.500043,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.443836, 0, 0, 0.502983,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -0.0338911, 1, -1, 0.464413,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.547008, 1, 0, 0.50101,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0250485);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.546845,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.51051,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.490683,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.185953, 0, 0, 0.496903,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.435864,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.0817468, 0, 0, 0.494863,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -0.146146, 1, 0, 0.496349,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0289592);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.63982,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.442936,-99) , 
8, 0, 0, 0, -2.01116, 2.90257, 0, 0, 0.134447, 7, 0.0174233, 0, 0, 0.549493,-99) , 
NN(
0, 
0, 
8, 0, 0, 0, -0.500658, 0.520985, 0, 0, 0.00916775, -1, -0.0301273, 0, -1, 0.495483,-99) , 
8, 0, 0, 0, 0.0335872, -0.0439614, 0, 0, 7.56081e-05, 7, 0.00189057, 0, 0, 0.500387,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.464714,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.547008, 1, 0, 0.498564,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0281987);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.566545,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.50794,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.382901,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.380866, 1, 0, 0.504362,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.443836, 0, 0, 0.506917,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.471925,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0.547008, 1, 0, 0.50513,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0320942);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.186229, 0, 1, 0.5138,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.540429,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.488965,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.0481558, 0, 0, 0.493904,-99) , 
8, 0, 0, 0, 0.0786795, -0.180953, 0, 0, 0.0111337, 7, 0.0044654, 0, 0, 0.502838,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.00257981, 1, -1, 0.460914,-99) , 
8, 0, 0, 0, 0.0598366, -0.121626, 0, 0, 0.00561344, 7, 0.00525279, 1, 0, 0.499168,-99)    );
   return;
};

// Clean up
inline void ReadBDTF::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDTF::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
